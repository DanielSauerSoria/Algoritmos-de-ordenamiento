# -*- coding: utf-8 -*-
"""Algoritmos de ordenamiento.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o-zFiXgAyg8eWCsJGICkfv71qlnpR1Kz

**Librerías utilizadas**
"""

import random
import time
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from IPython.display import HTML

"""**Definición de algoritmos de ordenamiento**"""

def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i-1
        while j >= 0 and key < arr[j]:
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = key
    return arr

def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr)//2
        L = arr[:mid]
        R = arr[mid:]
        merge_sort(L)
        merge_sort(R)
        i = j = k = 0
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1
        while i < len(L):
            arr[k] = L[i]
            i += 1
            k += 1
        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1
    return arr

def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    else:
        pivot = arr[len(arr)//2]
        left = [x for x in arr if x < pivot]
        middle = [x for x in arr if x == pivot]
        right = [x for x in arr if x > pivot]
        return quick_sort(left) + middle + quick_sort(right)

"""**Medición de tiempos de ejecución**"""

SIZE = 1000
MAX_VALUE = 1000
data = [random.randint(0, MAX_VALUE) for _ in range(SIZE)]

algorithms = [
    ("Bubble Sort", bubble_sort),
    ("Selection Sort", selection_sort),
    ("Insertion Sort", insertion_sort),
    ("Merge Sort", merge_sort),
    ("Quick Sort", quick_sort),
]

times = []

print("⏱️ Tiempos de ejecución:\n")
for name, func in algorithms:
    arr = data.copy()
    start = time.time()
    if name == "Quick Sort":
        arr = func(arr)  # quick_sort returns a new list
    else:
        func(arr)
    end = time.time()
    duration = end - start
    times.append(duration)
    assert arr == sorted(data), f"{name} falló en ordenar correctamente."
    print(f"{name:15} ➜ {duration:.6f} segundos")

"""**Gráfica comparativa de tiempos**"""

plt.figure(figsize=(10,6))
plt.bar([name for name, _ in algorithms], times, color='skyblue')
plt.ylabel('Tiempo (segundos)')
plt.title('Comparación de tiempos de ejecución')
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

"""**Funcion para realizar las animaciones**"""

def animate_sort(frames, title="Animación del algoritmo de ordenamiento"):
    fig, ax = plt.subplots()
    plt.close(fig)
    bar_rects = ax.bar(range(len(frames[0][0])), frames[0][0], color=frames[0][1])
    ax.set_title(title)
    ax.set_xlabel("Índice")
    ax.set_ylabel("Valor")
    ax.set_ylim(0, max(frames[0][0]) + 1)

    def update(frame):
        heights, colors = frame
        for rect, h, c in zip(bar_rects, heights, colors):
            rect.set_height(h)
            rect.set_color(c)
        return bar_rects

    anim = animation.FuncAnimation(fig, update, frames=frames, interval=50, repeat=False)
    return HTML(anim.to_jshtml())

""" **Animación de Bubble Sort**"""

def bubble_sort_visual(arr):
    frames = []
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            frame = arr.copy()
            color = ['blue'] * len(arr)
            color[j] = 'red'
            color[j + 1] = 'green'
            frames.append((frame, color))
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                frame = arr.copy()
                color = ['blue'] * len(arr)
                color[j] = 'purple'
                color[j + 1] = 'purple'
                frames.append((frame, color))
    return frames

size = 25
data = [random.randint(1, 100) for _ in range(size)]
frames = bubble_sort_visual(data.copy())
animate_sort(frames, title="Bubble Sort - Visualización")

"""**Animación de Selecction Sort**"""

def selection_sort_visual(arr):
    frames = []
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            frame = arr.copy()
            color = ['blue'] * len(arr)
            color[i] = 'green'
            color[j] = 'red'
            color[min_idx] = 'orange'
            frames.append((frame, color))
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
        frame = arr.copy()
        color = ['blue'] * len(arr)
        color[i] = 'purple'
        frames.append((frame, color))
    return frames

size = 25
data = [random.randint(1, 100) for _ in range(size)]
frames = selection_sort_visual(data.copy())
animate_sort(frames, title="Selection Sort - Visualización")

"""**Animación de Insertion Sort**"""

def insertion_sort_visual(arr):
    frames = []
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and key < arr[j]:
            frame = arr.copy()
            color = ['blue'] * len(arr)
            color[j] = 'red'
            color[j + 1] = 'green'
            frames.append((frame, color))
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
        frame = arr.copy()
        color = ['blue'] * len(arr)
        color[j + 1] = 'purple'
        frames.append((frame, color))
    return frames

size = 25
data = [random.randint(1, 100) for _ in range(size)]
frames = insertion_sort_visual(data.copy())
animate_sort(frames, title="Insertion Sort - Visualización")

"""**Animación de Merge Sort**"""

def merge_sort_visual(arr):
    frames = []
    def merge_sort(arr, l, r):
        if l < r:
            m = (l + r) // 2
            merge_sort(arr, l, m)
            merge_sort(arr, m + 1, r)
            merge(arr, l, m, r)

    def merge(arr, l, m, r):
        left = arr[l:m + 1]
        right = arr[m + 1:r + 1]
        i = j = 0
        k = l
        while i < len(left) and j < len(right):
            frame = arr.copy()
            color = ['blue'] * len(arr)
            color[k] = 'green'
            frames.append((frame, color))
            if left[i] <= right[j]:
                arr[k] = left[i]
                i += 1
            else:
                arr[k] = right[j]
                j += 1
            k += 1
        while i < len(left):
            frame = arr.copy()
            color = ['blue'] * len(arr)
            color[k] = 'orange'
            frames.append((frame, color))
            arr[k] = left[i]
            i += 1
            k += 1
        while j < len(right):
            frame = arr.copy()
            color = ['blue'] * len(arr)
            color[k] = 'orange'
            frames.append((frame, color))
            arr[k] = right[j]
            j += 1
            k += 1

    arr_copy = arr.copy()
    merge_sort(arr_copy, 0, len(arr_copy) - 1)
    return frames

size = 25
data = [random.randint(1, 100) for _ in range(size)]
frames = merge_sort_visual(data.copy())
animate_sort(frames, title="Merge Sort - Visualización")

"""**Animación de Quick Sort**"""

def quick_sort_visual(arr):
    frames = []
    def quick_sort(arr, low, high):
        if low < high:
            pi = partition(arr, low, high)
            quick_sort(arr, low, pi - 1)
            quick_sort(arr, pi + 1, high)

    def partition(arr, low, high):
        pivot = arr[high]
        i = low - 1
        for j in range(low, high):
            frame = arr.copy()
            color = ['blue'] * len(arr)
            color[high] = 'orange'
            color[j] = 'red'
            color[i] = 'green' if i >= 0 else 'blue'
            frames.append((frame, color))
            if arr[j] <= pivot:
                i += 1
                arr[i], arr[j] = arr[j], arr[i]
                frame = arr.copy()
                color = ['blue'] * len(arr)
                color[i] = 'purple'
                color[j] = 'purple'
                color[high] = 'orange'
                frames.append((frame, color))
        arr[i + 1], arr[high] = arr[high], arr[i + 1]
        frame = arr.copy()
        color = ['blue'] * len(arr)
        color[i + 1] = 'green'
        frames.append((frame, color))
        return i + 1

    arr_copy = arr.copy()
    quick_sort(arr_copy, 0, len(arr_copy) - 1)
    return frames

size = 25
data = [random.randint(1, 100) for _ in range(size)]
frames = quick_sort_visual(data.copy())
animate_sort(frames, title="Quick Sort - Visualización")